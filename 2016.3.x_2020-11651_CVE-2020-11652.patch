From e3465784cae915cf75fa3c7e3fbfbce264e1e1f2 Mon Sep 17 00:00:00 2001
From: ch3ll <megan.wilhite@gmail.com>
Date: Fri, 1 May 2020 15:53:43 -0400
Subject: [PATCH] CVE-2020-11651 and CVE-2020-11652

---
 salt/master.py           | 62 +++++++++++++++++++++++++++++++++-------
 salt/utils/verify.py     | 58 +++++++++++++++++++++++++++++++++----
 salt/wheel/config.py     |  5 ++++
 salt/wheel/file_roots.py |  8 +++++-
 4 files changed, 116 insertions(+), 17 deletions(-)

diff --git a/salt/master.py b/salt/master.py
index ecc037b863..c964eb7605 100644
--- a/salt/master.py
+++ b/salt/master.py
@@ -858,10 +858,10 @@ class MWorker(SignalHandlingMultiprocessingProcess):
         :return: The result of passing the load to a function in ClearFuncs corresponding to
                  the command specified in the load's 'cmd' key.
         '''
-        log.trace('Clear payload received with command {cmd}'.format(**load))
-        if load['cmd'].startswith('__'):
-            return False
-        return getattr(self.clear_funcs, load['cmd'])(load), {'fun': 'send_clear'}
+        log.trace('Clear payload received with command %s', load['cmd'])
+        cmd = load['cmd']
+        method = self.clear_funcs.get_method(cmd)
+        return method(load), {'fun': 'send_clear'}
 
     def _handle_aes(self, data):
         '''
@@ -874,9 +874,11 @@ class MWorker(SignalHandlingMultiprocessingProcess):
         if 'cmd' not in data:
             log.error('Received malformed command {0}'.format(data))
             return {}
-        log.trace('AES payload received with command {0}'.format(data['cmd']))
-        if data['cmd'].startswith('__'):
-            return False
+        cmd = data['cmd']
+        log.trace('AES payload received with command %s', data['cmd'])
+        method = self.aes_funcs.get_method(cmd)
+        if not method:
+            return {}, {'fun': 'send'}
         return self.aes_funcs.run_func(data['cmd'], data)
 
     def run(self):
@@ -893,13 +895,44 @@ class MWorker(SignalHandlingMultiprocessingProcess):
         self.__bind()
 
 
+class TransportMethods(object):
+    '''
+    Expose methods to the transport layer, methods with their names found in
+    the class attribute 'expose_methods' will be exposed to the transport layer
+    via 'get_method'.
+    '''
+
+    expose_methods = ()
+
+    def get_method(self, name):
+        '''
+        Get a method which should be exposed to the transport layer
+        '''
+        if name in self.expose_methods:
+            try:
+                return getattr(self, name)
+            except AttributeError:
+                log.error("Expose method not found: %s", name)
+        else:
+            log.error("Requested method not exposed: %s", name)
+
+
 # TODO: rename? No longer tied to "AES", just "encrypted" or "private" requests
-class AESFuncs(object):
+class AESFuncs(TransportMethods):
     '''
     Set up functions that are available when the load is encrypted with AES
     '''
-    # The AES Functions:
-    #
+
+    expose_methods = (
+        'verify_minion', '_master_tops', '_ext_nodes', '_master_opts',
+        '_mine_get', '_mine', '_mine_delete', '_mine_flush', '_file_recv',
+        '_pillar', '_minion_event', '_handle_minion_event', '_return',
+        '_syndic_return', 'minion_runner', 'pub_ret', 'minion_pub',
+        'minion_publish', 'revoke_auth', 'run_func', '_serve_file',
+        '_file_find', '_file_hash', '_file_find_and_stat', '_file_list',
+        '_file_list_emptydirs', '_dir_list', '_symlink_list', '_file_envs',
+    )
+
     def __init__(self, opts):
         '''
         Create a new AESFuncs
@@ -1596,11 +1629,18 @@ class AESFuncs(object):
         return ret, {'fun': 'send'}
 
 
-class ClearFuncs(object):
+class ClearFuncs(TransportMethods):
     '''
     Set up functions that are safe to execute when commands sent to the master
     without encryption and authentication
     '''
+
+    # These methods will be exposed to the transport layer by
+    # MWorker._handle_clear
+    expose_methods = (
+        'ping', 'publish', 'get_token', 'mk_token', 'wheel', 'runner',
+    )
+
     # The ClearFuncs object encapsulates the functions that can be executed in
     # the clear:
     # publish (The publish from the LocalClient)
diff --git a/salt/utils/verify.py b/salt/utils/verify.py
index 6c3e606f72..4e8455fff6 100644
--- a/salt/utils/verify.py
+++ b/salt/utils/verify.py
@@ -27,6 +27,7 @@ from salt.log.setup import LOG_LEVELS
 from salt.exceptions import SaltClientError, SaltSystemExit
 import salt.defaults.exitcodes
 import salt.utils
+import salt.ext.six
 
 log = logging.getLogger(__name__)
 
@@ -465,23 +466,70 @@ def check_max_open_files(opts):
     log.log(level=level, msg=msg)
 
 
+def _realpath_darwin(path):
+    base = ''
+    for part in path.split(os.path.sep)[1:]:
+        if base != '':
+            if os.path.islink(os.path.sep.join([base, part])):
+                base = os.readlink(os.path.sep.join([base, part]))
+            else:
+                base = os.path.abspath(os.path.sep.join([base, part]))
+        else:
+            base = os.path.abspath(os.path.sep.join([base, part]))
+    return base
+
+
+def _realpath_windows(path):
+    base = ''
+    for part in path.split(os.path.sep):
+        if base != '':
+            try:
+                part = os.readlink(os.path.sep.join([base, part]))
+                base = os.path.abspath(part)
+            except OSError:
+                base = os.path.abspath(os.path.sep.join([base, part]))
+        else:
+            base = part
+    return base
+
+
+def _realpath(path):
+    '''
+    Cross platform realpath method. On Windows when python 3, this method
+    uses the os.readlink method to resolve any filesystem links. On Windows
+    when python 2, this method is a no-op. All other platforms and version use
+    os.realpath
+    '''
+    if sys.platform.startswith("darwin"):
+        return _realpath_darwin(path)
+    elif sys.platform.startswith("win"):
+        if salt.ext.six.PY3:
+            return _realpath_windows(path)
+        else:
+            return path
+    return os.path.realpath(path)
+
+
 def clean_path(root, path, subdir=False):
     '''
     Accepts the root the path needs to be under and verifies that the path is
     under said root. Pass in subdir=True if the path can result in a
     subdirectory of the root instead of having to reside directly in the root
     '''
-    if not os.path.isabs(root):
+    real_root = _realpath(root)
+    if not os.path.isabs(real_root):
         return ''
     if not os.path.isabs(path):
         path = os.path.join(root, path)
     path = os.path.normpath(path)
+    real_path = _realpath(path)
     if subdir:
-        if path.startswith(root):
-            return path
+        if real_path.startswith(real_root):
+            return real_path
     else:
-        if os.path.dirname(path) == os.path.normpath(root):
-            return path
+        if os.path.dirname(real_path) == os.path.normpath(real_root):
+            return real_path
+
     return ''
 
 
diff --git a/salt/wheel/config.py b/salt/wheel/config.py
index c4976fa45c..db6f98ca36 100644
--- a/salt/wheel/config.py
+++ b/salt/wheel/config.py
@@ -13,6 +13,8 @@ import yaml
 
 # Import salt libs
 import salt.config
+import salt.utils
+import salt.utils.verify
 
 log = logging.getLogger(__name__)
 
@@ -80,6 +82,9 @@ def update_config(file_name, yaml_contents):
             os.makedirs(dir_path, 0o755)
 
         file_path = os.path.join(dir_path, file_name)
+        if not salt.utils.verify.clean_path(dir_path, file_path):
+            return 'Invalid path'
+
         with salt.utils.fopen(file_path, 'w') as fp_:
             fp_.write(yaml_out)
 
diff --git a/salt/wheel/file_roots.py b/salt/wheel/file_roots.py
index aef90fbd15..10cc33ecd8 100644
--- a/salt/wheel/file_roots.py
+++ b/salt/wheel/file_roots.py
@@ -9,6 +9,7 @@ import os
 
 # Import salt libs
 import salt.utils
+import salt.utils.verify
 
 # Import 3rd-party libs
 import salt.ext.six as six
@@ -33,6 +34,8 @@ def find(path, saltenv='base', env=None):
         return ret
     for root in __opts__['file_roots'][saltenv]:
         full = os.path.join(root, path)
+        if not salt.utils.verify.clean_path(root, full):
+            continue
         if os.path.isfile(full):
             # Add it to the dict
             with salt.utils.fopen(full, 'rb') as fp_:
@@ -140,7 +143,10 @@ def write(data, path, saltenv='base', index=0, env=None):
     if os.path.isabs(path):
         return ('The path passed in {0} is not relative to the environment '
                 '{1}').format(path, saltenv)
-    dest = os.path.join(__opts__['file_roots'][saltenv][index], path)
+    root = __opts__['file_roots'][saltenv][index]
+    dest = os.path.join(root, path)
+    if not salt.utils.verify.clean_path(root, dest, subdir=True):
+        return 'Invalid path: {}'.format(path)
     dest_dir = os.path.dirname(dest)
     if not os.path.isdir(dest_dir):
         os.makedirs(dest_dir)
-- 
2.26.0

